From 8aa87a051f6451ecb1cc83ec4bd9294ab2a3508b Mon Sep 17 00:00:00 2001
From: Adin Scannell <amscanne@meta.com>
Date: Wed, 24 Sep 2025 14:20:43 -0700
Subject: [PATCH] opaque value: handle unaligned accesses

Since the types being bitcast will generally be small, it is more
efficient to simply return an instance of these types. This requires
that they are trivially copyable (which will be the case already).

Note that the `constexpr` if is not a premature optimization here; some
copied types lack a default constructor but *are* copyable. We still
require them to be trivially copyable (to avoid that set of footguns),
but allows these for objects that don't have alignment constraints.

Fixes #4644

Signed-off-by: Adin Scannell <amscanne@meta.com>

stack-info: PR: https://github.com/bpftrace/bpftrace/pull/4651, branch: user/amscanne/fix_alignment/1
---
 src/ast/async_event_types.h |  5 -----
 src/async_action.cpp        | 28 +++++++++++++---------------
 src/types_format.cpp        | 10 ++++++----
 src/util/opaque.h           | 18 ++++++++++++++++--
 src/util/tseries.cpp        |  2 +-
 5 files changed, 36 insertions(+), 27 deletions(-)

diff --git a/src/ast/async_event_types.h b/src/ast/async_event_types.h
index eaf5b4dde12f..76a43432aedf 100644
--- a/src/ast/async_event_types.h
+++ b/src/ast/async_event_types.h
@@ -65,11 +65,6 @@ struct Strftime {
 
 struct Buf {
   uint32_t length;
-  // Seems like GCC 7.4.x can't handle `char content[]`. Work around by using
-  // 0 sized array (a GCC extension that clang also accepts:
-  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70932). It also looks like
-  // the issue doesn't exist in GCC 7.5.x.
-  char content[0];
 
   std::vector<llvm::Type*> asLLVMType(ast::IRBuilderBPF& b, uint32_t length);
 } __attribute__((packed));
diff --git a/src/async_action.cpp b/src/async_action.cpp
index adf6eee480e4..c360c7c270b4 100644
--- a/src/async_action.cpp
+++ b/src/async_action.cpp
@@ -34,14 +34,14 @@ static Result<std::vector<output::Primitive>> prepare_args(
 
 void AsyncHandlers::exit(const OpaqueValue &data)
 {
-  const auto &exit = data.bitcast<AsyncEvent::Exit>();
+  auto exit = data.bitcast<AsyncEvent::Exit>();
   BPFtrace::exit_code = exit.exit_code;
   bpftrace.request_finalize();
 }
 
 void AsyncHandlers::join(const OpaqueValue &data)
 {
-  const auto &join = data.bitcast<AsyncEvent::Join>();
+  auto join = data.bitcast<AsyncEvent::Join>();
   uint64_t join_id = join.join_id;
   const auto *delim = bpftrace.resources.join_args[join_id].c_str();
   auto arg = data.slice(sizeof(AsyncEvent::Join));
@@ -66,7 +66,7 @@ void AsyncHandlers::time(const OpaqueValue &data)
     LOG(WARNING) << "localtime_r: " << strerror(errno);
     return;
   }
-  const auto &time = data.bitcast<AsyncEvent::Time>();
+  auto time = data.bitcast<AsyncEvent::Time>();
   const auto *fmt = bpftrace.resources.time_args[time.time_id].c_str();
   if (strftime(timestr, sizeof(timestr), fmt, &tmp) == 0) {
     LOG(WARNING) << "strftime returned 0";
@@ -77,7 +77,7 @@ void AsyncHandlers::time(const OpaqueValue &data)
 
 void AsyncHandlers::runtime_error(const OpaqueValue &data)
 {
-  const auto &runtime_error = data.bitcast<AsyncEvent::RuntimeError>();
+  auto runtime_error = data.bitcast<AsyncEvent::RuntimeError>();
   auto error_id = runtime_error.error_id;
   const auto return_value = runtime_error.return_value;
   const auto &info = bpftrace.resources.runtime_error_info[error_id];
@@ -86,14 +86,12 @@ void AsyncHandlers::runtime_error(const OpaqueValue &data)
 
 void AsyncHandlers::print_non_map(const OpaqueValue &data)
 {
-  const auto &print = data.bitcast<AsyncEvent::PrintNonMap>();
+  auto print = data.bitcast<AsyncEvent::PrintNonMap>();
   const SizedType &ty = bpftrace.resources.non_map_print_args.at(
       print.print_id);
 
-  auto v = format(bpftrace,
-                  c_definitions,
-                  ty,
-                  OpaqueValue::from(&print.content[0], ty.GetSize()));
+  auto v = format(
+      bpftrace, c_definitions, ty, data.slice(sizeof(AsyncEvent::PrintNonMap)));
   if (!v) {
     LOG(BUG) << "error printing non-map value: " << v.takeError();
   }
@@ -102,7 +100,7 @@ void AsyncHandlers::print_non_map(const OpaqueValue &data)
 
 void AsyncHandlers::print_map(const OpaqueValue &data)
 {
-  const auto &print = data.bitcast<AsyncEvent::Print>();
+  auto print = data.bitcast<AsyncEvent::Print>();
   const auto &map = bpftrace.bytecode_.getMap(print.mapid);
 
   auto res = format(bpftrace, c_definitions, map, print.top, print.div);
@@ -116,7 +114,7 @@ void AsyncHandlers::print_map(const OpaqueValue &data)
 
 void AsyncHandlers::zero_map(const OpaqueValue &data)
 {
-  const auto &mapevent = data.bitcast<AsyncEvent::MapEvent>();
+  auto mapevent = data.bitcast<AsyncEvent::MapEvent>();
   const auto &map = bpftrace.bytecode_.getMap(mapevent.mapid);
   uint64_t nvalues = map.is_per_cpu_type() ? bpftrace.ncpus_ : 1;
   auto ok = map.zero_out(nvalues);
@@ -129,7 +127,7 @@ void AsyncHandlers::zero_map(const OpaqueValue &data)
 
 void AsyncHandlers::clear_map(const OpaqueValue &data)
 {
-  const auto &mapevent = data.bitcast<AsyncEvent::MapEvent>();
+  auto mapevent = data.bitcast<AsyncEvent::MapEvent>();
   const auto &map = bpftrace.bytecode_.getMap(mapevent.mapid);
   uint64_t nvalues = map.is_per_cpu_type() ? bpftrace.ncpus_ : 1;
   auto ok = map.clear(nvalues);
@@ -141,7 +139,7 @@ void AsyncHandlers::clear_map(const OpaqueValue &data)
 
 void AsyncHandlers::watchpoint_attach(const OpaqueValue &data)
 {
-  const auto &watchpoint = data.bitcast<AsyncEvent::Watchpoint>();
+  auto watchpoint = data.bitcast<AsyncEvent::Watchpoint>();
   uint64_t probe_idx = watchpoint.watchpoint_idx;
   uint64_t addr = watchpoint.addr;
 
@@ -192,7 +190,7 @@ void AsyncHandlers::watchpoint_attach(const OpaqueValue &data)
 
 void AsyncHandlers::watchpoint_detach(const OpaqueValue &data)
 {
-  const auto &unwatch = data.bitcast<AsyncEvent::WatchpointUnwatch>();
+  auto unwatch = data.bitcast<AsyncEvent::WatchpointUnwatch>();
   uint64_t addr = unwatch.addr;
 
   // Remove all probes watching `addr`. Note how we fail silently here
@@ -208,7 +206,7 @@ void AsyncHandlers::watchpoint_detach(const OpaqueValue &data)
 
 void AsyncHandlers::skboutput(const OpaqueValue &data)
 {
-  const auto &hdr = data.bitcast<AsyncEvent::SkbOutput>();
+  auto hdr = data.bitcast<AsyncEvent::SkbOutput>();
   int offset = std::get<1>(
       bpftrace.resources.skboutput_args_.at(hdr.skb_output_id));
   auto pkt = data.slice(sizeof(hdr));
diff --git a/src/types_format.cpp b/src/types_format.cpp
index 932bbccaed84..bb69a2a6860e 100644
--- a/src/types_format.cpp
+++ b/src/types_format.cpp
@@ -82,10 +82,12 @@ Result<output::Primitive> format(BPFtrace &bpftrace,
       return bpftrace.resolve_uid(value.bitcast<uint64_t>());
     }
     case Type::buffer: {
-      const auto &buf = value.bitcast<AsyncEvent::Buf>();
+      auto buf = value.bitcast<AsyncEvent::Buf>();
+      size_t length = buf.length;
       output::Primitive::Buffer v;
       v.data.resize(buf.length);
-      memcpy(v.data.data(), buf.content, buf.length);
+      const auto *content = value.slice(sizeof(AsyncEvent::Buf), length).data();
+      memcpy(v.data.data(), content, length);
       return v;
     }
     case Type::string: {
@@ -227,7 +229,7 @@ Result<output::Primitive> format(BPFtrace &bpftrace,
       // string. We could optionally store just a native nsec timestamp, and
       // allow the output to choose the format. We will leave this for a future
       // type. For now this both resolves and formats the time.
-      const auto &s = value.bitcast<const AsyncEvent::Strftime>();
+      auto s = value.bitcast<const AsyncEvent::Strftime>();
       const auto ts = bpftrace.resolve_timestamp(s.mode, s.nsecs);
       return bpftrace.format_timestamp(ts, s.strftime_id);
     }
@@ -235,7 +237,7 @@ Result<output::Primitive> format(BPFtrace &bpftrace,
       return bpftrace.resolve_mac_address(value.data());
     }
     case Type::cgroup_path_t: {
-      const auto &c = value.bitcast<const AsyncEvent::CgroupPath>();
+      auto c = value.bitcast<const AsyncEvent::CgroupPath>();
       return bpftrace.resolve_cgroup_path(c.cgroup_path_id, c.cgroup_id);
     }
     case Type::strerror_t: {
diff --git a/src/util/opaque.h b/src/util/opaque.h
index 9b20a96b19f4..3baff678ecba 100644
--- a/src/util/opaque.h
+++ b/src/util/opaque.h
@@ -6,6 +6,7 @@
 #include <functional>
 #include <memory>
 #include <optional>
+#include <type_traits>
 #include <utility>
 #include <variant>
 
@@ -144,10 +145,23 @@ class OpaqueValue {
   }
 
   template <typename T>
-  const T &bitcast(size_t index = 0) const
+    requires(std::is_trivially_copyable_v<T>)
+  T bitcast(size_t index = 0) const
   {
     check(sizeof(T) * index, sizeof(T));
-    return reinterpret_cast<const T *>(data())[index];
+    const T *src = reinterpret_cast<const T *>(data()) + index;
+    // Some existing types are packed structures that don't have default
+    // constructors (although they are trivially copyable). Therefore, if we
+    // don't have any alignment constraints, avoid the constructor and do the
+    // direct copy out. If we do have alignment constraints, allow the memcpy
+    // to do all the heavy lifting.
+    if constexpr (std::alignment_of_v<T> <= 1) {
+      return *src;
+    } else {
+      T result;
+      std::memcpy(&result, src, sizeof(result));
+      return result;
+    }
   }
 
   bool operator==(const OpaqueValue &other) const;
diff --git a/src/util/tseries.cpp b/src/util/tseries.cpp
index 2f2fc6d7bb70..1a5b2096b121 100644
--- a/src/util/tseries.cpp
+++ b/src/util/tseries.cpp
@@ -22,7 +22,7 @@ std::pair<uint64_t, uint64_t> reduce_tseries_value(const OpaqueValue &value,
   uint64_t latest_epoch = 0;
 
   for (size_t i = 0; i < value.count<tseries_data<T>>(); i++) {
-    const auto &v = value.bitcast<tseries_data<T>>(i);
+    auto v = value.bitcast<tseries_data<T>>(i);
     if (v.epoch == 0) {
       // Don't consider buckets where epoch is 0. This means it was never used.
       continue;

Manual backport of:
https://lore.kernel.org/linux-perf-users/20251112074311.1440101-1-irogers@google.com/

--- a/tools/perf/util/mutex.c
+++ b/tools/perf/util/mutex.c
@@ -17,7 +17,7 @@ static void check_err(const char *fn, in
 
 #define CHECK_ERR(err) check_err(__func__, err)
 
-static void __mutex_init(struct mutex *mtx, bool pshared)
+static void __mutex_init(struct mutex *mtx, bool pshared, bool recursive)
 {
 	pthread_mutexattr_t attr;
 
@@ -27,21 +27,27 @@ static void __mutex_init(struct mutex *m
 	/* In normal builds enable error checking, such as recursive usage. */
 	CHECK_ERR(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK));
 #endif
+	if (recursive)
+		CHECK_ERR(pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE));
 	if (pshared)
 		CHECK_ERR(pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED));
-
 	CHECK_ERR(pthread_mutex_init(&mtx->lock, &attr));
 	CHECK_ERR(pthread_mutexattr_destroy(&attr));
 }
 
 void mutex_init(struct mutex *mtx)
 {
-	__mutex_init(mtx, /*pshared=*/false);
+	__mutex_init(mtx, /*pshared=*/false, /*recursive=*/false);
 }
 
 void mutex_init_pshared(struct mutex *mtx)
 {
-	__mutex_init(mtx, /*pshared=*/true);
+	__mutex_init(mtx, /*pshared=*/true, /*recursive=*/false);
+}
+
+void mutex_init_recursive(struct mutex *mtx)
+{
+	__mutex_init(mtx, /*pshared=*/false, /*recursive=*/true);
 }
 
 void mutex_destroy(struct mutex *mtx)
--- a/tools/perf/util/mutex.h
+++ b/tools/perf/util/mutex.h
@@ -104,6 +104,8 @@ void mutex_init(struct mutex *mtx);
  * process-private attribute.
  */
 void mutex_init_pshared(struct mutex *mtx);
+/* Initializes a mutex that may be recursively held on the same thread. */
+void mutex_init_recursive(struct mutex *mtx);
 void mutex_destroy(struct mutex *mtx);
 
 void mutex_lock(struct mutex *mtx) EXCLUSIVE_LOCK_FUNCTION(*mtx);
--- a/tools/perf/util/srcline.c
+++ b/tools/perf/util/srcline.c
@@ -1,4 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
+#include <fcntl.h>
 #include <inttypes.h>
 #include <signal.h>
 #include <stdio.h>
@@ -208,6 +209,71 @@ struct a2l_data {
 	asymbol 	**syms;
 };
 
+static bool perf_bfd_lock(void *bfd_mutex)
+{
+	mutex_lock(bfd_mutex);
+	return true;
+}
+
+static bool perf_bfd_unlock(void *bfd_mutex)
+{
+	mutex_unlock(bfd_mutex);
+	return true;
+}
+
+static void perf_bfd_init(void)
+{
+	static struct mutex bfd_mutex;
+
+	mutex_init_recursive(&bfd_mutex);
+
+	if (bfd_init() != BFD_INIT_MAGIC) {
+		pr_err("Error initializing libbfd\n");
+		return;
+	}
+	if (!bfd_thread_init(perf_bfd_lock, perf_bfd_unlock, &bfd_mutex))
+		pr_err("Error initializing libbfd threading\n");
+}
+
+static void ensure_bfd_init(void)
+{
+	static pthread_once_t bfd_init_once = PTHREAD_ONCE_INIT;
+
+	pthread_once(&bfd_init_once, perf_bfd_init);
+}
+
+int libbfd_read_build_id(const char *filename, struct build_id *bid, bool block)
+{
+    size_t size = sizeof(bid->data);
+    int err = -1, fd;
+    bfd *abfd;
+
+    ensure_bfd_init();
+    fd = open(filename, block ? O_RDONLY : (O_RDONLY | O_NONBLOCK));
+    if (fd < 0)
+        return -1;
+
+    abfd = bfd_fdopenr(filename, /*target=*/NULL, fd);
+    if (!abfd)
+        return -1;
+
+    if (!bfd_check_format(abfd, bfd_object)) {
+        pr_debug2("%s: cannot read %s bfd file.\n", __func__, filename);
+        goto out_close;
+    }
+
+    if (!abfd->build_id || abfd->build_id->size > size)
+        goto out_close;
+
+    memcpy(bid->data, abfd->build_id->data, abfd->build_id->size);
+    memset(bid->data + abfd->build_id->size, 0, size - abfd->build_id->size);
+    err = bid->size = abfd->build_id->size;
+
+out_close:
+    bfd_close(abfd);
+    return err;
+}
+
 static int bfd_error(const char *string)
 {
 	const char *errmsg;
@@ -302,6 +369,7 @@ static struct a2l_data *addr2line_init(c
 	bfd *abfd;
 	struct a2l_data *a2l = NULL;
 
+	ensure_bfd_init();
 	abfd = bfd_openr(path, NULL);
 	if (abfd == NULL)
 		return NULL;
--- a/tools/perf/util/srcline.h
+++ b/tools/perf/util/srcline.h
@@ -8,6 +8,9 @@
 
 struct dso;
 struct symbol;
+struct build_id;
+
+int libbfd_read_build_id(const char *filename, struct build_id *bid, bool block);
 
 extern int addr2line_timeout_ms;
 extern bool srcline_full_filename;
--- a/tools/perf/util/symbol-elf.c
+++ b/tools/perf/util/symbol-elf.c
@@ -873,35 +873,11 @@ out:
 
 #ifdef HAVE_LIBBFD_BUILDID_SUPPORT
 
+int libbfd_read_build_id(const char *filename, struct build_id *bid, bool block);
+
 static int read_build_id(const char *filename, struct build_id *bid, bool block)
 {
-	size_t size = sizeof(bid->data);
-	int err = -1, fd;
-	bfd *abfd;
-
-	fd = open(filename, block ? O_RDONLY : (O_RDONLY | O_NONBLOCK));
-	if (fd < 0)
-		return -1;
-
-	abfd = bfd_fdopenr(filename, /*target=*/NULL, fd);
-	if (!abfd)
-		return -1;
-
-	if (!bfd_check_format(abfd, bfd_object)) {
-		pr_debug2("%s: cannot read %s bfd file.\n", __func__, filename);
-		goto out_close;
-	}
-
-	if (!abfd->build_id || abfd->build_id->size > size)
-		goto out_close;
-
-	memcpy(bid->data, abfd->build_id->data, abfd->build_id->size);
-	memset(bid->data + abfd->build_id->size, 0, size - abfd->build_id->size);
-	err = bid->size = abfd->build_id->size;
-
-out_close:
-	bfd_close(abfd);
-	return err;
+	return libbfd_read_build_id(filename, bid, block);
 }
 
 #else // HAVE_LIBBFD_BUILDID_SUPPORT

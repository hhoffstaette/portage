--- rustic_core-0.9.0/src/commands/check.rs
+++ rustic_core-0.9.0/src/commands/check.rs
@@ -258,7 +258,7 @@ pub(crate) fn check_repository<P: Progre
 
                 let p = pb.progress_bytes(format!("checking {file_type:?} in cache..."));
                 // TODO: Make concurrency (20) customizable
-                check_cache_files(20, cache, raw_be, file_type, &p, &collector)?;
+                check_cache_files(4, cache, raw_be, file_type, &p, &collector)?;
             }
         }
     }
@@ -289,7 +289,7 @@ pub(crate) fn check_repository<P: Progre
         if !opts.trust_cache {
             let p = pb.progress_bytes("checking packs in cache...");
             // TODO: Make concurrency (5) customizable
-            check_cache_files(5, cache, raw_be, FileType::Pack, &p, &collector)?;
+            check_cache_files(4, cache, raw_be, FileType::Pack, &p, &collector)?;
         }
     }
 
--- rustic_core-0.9.0/src/commands/restore.rs
+++ rustic_core-0.9.0/src/commands/restore.rs
@@ -31,7 +31,7 @@ use crate::{
 
 pub(crate) mod constants {
     /// The maximum number of reader threads to use for restoring.
-    pub(crate) const MAX_READER_THREADS_NUM: usize = 20;
+    pub(crate) const MAX_READER_THREADS_NUM: usize = 1;
     /// The maximum size of pack-part which is read at once from the backend.
     /// (needed to limit the memory size used for large backends)
     pub(crate) const LIMIT_PACK_READ: u32 = 40 * 1024 * 1024; // 40 MiB
--- rustic_core-0.9.0/src/repository/warm_up.rs
+++ rustic_core-0.9.0/src/repository/warm_up.rs
@@ -15,7 +15,7 @@ use crate::{
 
 pub(super) mod constants {
     /// The maximum number of reader threads to use for warm-up.
-    pub(super) const MAX_READER_THREADS_NUM: usize = 20;
+    pub(super) const MAX_READER_THREADS_NUM: usize = 4;
 }
 
 /// Warm up the repository and wait.
